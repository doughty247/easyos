{
  description = "easyos - NixOS-based EASY appliance (WIP)";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.11";
    home-manager.url = "github:nix-community/home-manager/release-24.11";
    home-manager.inputs.nixpkgs.follows = "nixpkgs";
  };

  outputs = { self, nixpkgs, home-manager, ... }@inputs:
    let
      systems = [ "x86_64-linux" "aarch64-linux" ];
      forAllSystems = nixpkgs.lib.genAttrs systems;
      lib = nixpkgs.lib;

      # EASY Update Channels (SteamOS-style)
      # stable: LTS kernel, stable features (default)
      # beta: LTS kernel, beta features
      # preview: Latest kernel, bleeding edge features (manual build only)
      channelConfig = channel: {
        stable = {
          kernelPackages = "linuxPackages"; # LTS
          channelName = "stable";
        };
        beta = {
          kernelPackages = "linuxPackages"; # LTS
          channelName = "beta";
        };
        preview = {
          kernelPackages = "linuxPackages_latest"; # Latest kernel
          channelName = "preview";
        };
      }.${channel};

      # Helper to build NixOS config with channel settings
      mkEasyOS = { system ? "x86_64-linux", channel ? "stable" }:
        let
          pkgs = nixpkgs.legacyPackages.${system};
          chanConfig = channelConfig channel;
        in lib.nixosSystem {
          inherit system;
          specialArgs = { inherit inputs; }; # pass inputs to modules
          modules = [
            # Import hardware configuration (required for installed systems)
            ./hardware-configuration.nix
            ./modules/easyos.nix
            ./modules/network-performance.nix
            ./modules/network-autodiscovery.nix
            ./modules/hotspot.nix
            ./modules/backup.nix
            ./modules/storage-expansion.nix
            ./modules/webui.nix
            home-manager.nixosModules.home-manager
            {
              home-manager.useGlobalPkgs = true;
              home-manager.useUserPackages = true;

              # Channel-specific configuration
              boot.kernelPackages = lib.mkForce pkgs.${chanConfig.kernelPackages};
              environment.etc."easy/channel".text = chanConfig.channelName;
              # Ensure systemd-cryptenroll is available post-install
              environment.systemPackages = [ pkgs.systemd ];
            }
            ./easy-bootloader.nix
            ./easy-credentials.nix
            ./easy-encryption.nix
          ];
        };

      # Helper to build ISO with channel settings
      mkISO = { system ? "x86_64-linux", channel ? "stable" }:
        let
          pkgs = nixpkgs.legacyPackages.${system};
          chanConfig = channelConfig channel;
        in lib.nixosSystem {
          inherit system;
          specialArgs = { inherit inputs; };
          modules = [
            "${nixpkgs}/nixos/modules/installer/cd-dvd/installation-cd-minimal.nix"
            ./modules/easyos.nix
            ./modules/hotspot.nix
            ./modules/backup.nix
            ./modules/storage-expansion.nix
            ./modules/webui.nix
            home-manager.nixosModules.home-manager
            {
              home-manager.useGlobalPkgs = true;
              home-manager.useUserPackages = true;

              # Set state version for the ISO
              system.stateVersion = "24.11";

              # Channel-specific kernel configuration
              boot.kernelPackages = lib.mkForce pkgs.${chanConfig.kernelPackages};

              # ISO-specific overrides
              isoImage.makeEfiBootable = true;
              isoImage.makeUsbBootable = true;
              isoImage.volumeID = "EASYOS-${lib.toUpper chanConfig.channelName}";

              # Expose the channel inside the live ISO
              environment.etc."easy/channel".text = chanConfig.channelName;

              # Ship this flake's source as a tarball that the installer can extract
              # This avoids read-only filesystem issues when copying from ISO
              environment.etc."nixos/easyos.tar.gz" = {
                source = pkgs.runCommand "easyos-source-tar" {} ''
                  mkdir -p $out
                  cd ${self}
                  ${pkgs.gnutar}/bin/tar czf $out/easyos.tar.gz \
                    --exclude='.git' \
                    --exclude='result' \
                    --exclude='iso-output' \
                    --exclude='.nix-bincache' \
                    --transform 's,^./,easyos/,' \
                    .
                '';
              };

              # Ship helpful tools in the ISO
              environment.systemPackages = [
                nixpkgs.legacyPackages.x86_64-linux.git
                nixpkgs.legacyPackages.x86_64-linux.parted
                nixpkgs.legacyPackages.x86_64-linux.gptfdisk
                nixpkgs.legacyPackages.x86_64-linux.networkmanager
                nixpkgs.legacyPackages.x86_64-linux.openssl
                nixpkgs.legacyPackages.x86_64-linux.jq
                nixpkgs.legacyPackages.x86_64-linux.cryptsetup
                nixpkgs.legacyPackages.x86_64-linux.systemd
                nixpkgs.legacyPackages.x86_64-linux.qrencode
                # Make installer easily accessible as a command
                (nixpkgs.legacyPackages.x86_64-linux.writeShellScriptBin "easyos-install" ''
                  exec /etc/easyos-install.sh "$@"
                '')
                # Help command for EasyOS documentation and tips
                (nixpkgs.legacyPackages.x86_64-linux.writeShellScriptBin "easy-help" ''
                  cat << 'EOF'

EasyOS Installer - Quick Reference
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GETTING STARTED
    easyos-install                      Launch the installer
    sudo nmtui                          Configure network (if needed)

INSTALLER FEATURES
    • Automatic disk partitioning with Btrfs
    • Optional TPM2-backed LUKS encryption
    • QR code display for recovery keys
    • Network connectivity verification
    • Update channel selection (stable/beta/preview)

SYSTEM INFORMATION
    lsblk                               List block devices
    lsblk -f                            Show filesystem types
    cat /etc/easy/channel               Show ISO channel
    dmesg | grep -i tpm                 Check TPM2 detection
    ip addr show                        Show IP addresses

NETWORK SETUP
    sudo nmtui                          Network Manager TUI
    nmcli device wifi list              List Wi-Fi networks
    nmcli connection show               Show connections
    ping -c4 8.8.8.8                    Test connectivity

TROUBLESHOOTING
    journalctl -b                       View boot logs
    journalctl -f                       Follow live logs
    dmesg                               Kernel messages
    cat /tmp/easyos-install.log         Installer log (after install)

DOCUMENTATION
    README: /etc/nixos/easyos/README.md
    GitHub: https://github.com/doughty247/easyos

POST-INSTALL FEATURES
    • Router-grade WiFi hotspot (NAT, DHCP, DNS)
    • CAKE QoS with network auto-profiling
    • BBR congestion control
    • Web UI at http://<ip>:8088
    • Automatic Btrfs snapshots & backups

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Type 'easy-help' anytime to see this message
EOF
                '')
              ];

              # Auto-run installer on login - minimal setup, let installer handle network
              programs.bash.interactiveShellInit = ''
                # Show helpful tip on login
                echo ""
                echo "Welcome to EasyOS! Type 'easy-help' for quick commands and documentation."
                echo ""

                # Only run once per boot
                if [ ! -f /tmp/easyos-installer-run ]; then
                  touch /tmp/easyos-installer-run

                  # Enable WiFi if no ethernet is connected (for installer to use)
                  ETH_CONNECTED=$(nmcli -t -f TYPE,STATE device 2>/dev/null | grep -c '^ethernet:connected$' || true)

                  if [ "''${ETH_CONNECTED}" -ge 1 ]; then
                    echo "✓ Ethernet connection detected"
                    nmcli radio wifi off 2>/dev/null || true
                  else
                    echo "No ethernet detected - WiFi enabled for setup"
                    # Enable WiFi management for installer
                    if [ -f /etc/NetworkManager/conf.d/10-easyos-unmanaged-wifi.conf ]; then
                      sudo mv /etc/NetworkManager/conf.d/10-easyos-unmanaged-wifi.conf \
                         /etc/NetworkManager/conf.d/10-easyos-unmanaged-wifi.conf.disabled 2>/dev/null || true
                      sudo systemctl reload NetworkManager 2>/dev/null || true
                    fi
                    nmcli radio wifi on 2>/dev/null || true
                  fi

                  # Run installer with sudo (passwordless on live ISO)
                  sudo /etc/easyos-install.sh
                fi
              '';

              # Enable NetworkManager for easier network configuration in ISO
              networking.networkmanager.enable = true;
              networking.useNetworkd = lib.mkForce false;
              systemd.network.enable = lib.mkForce false;
              networking.wireless.enable = false; # Disable wpa_supplicant in favor of NetworkManager

              # Keep Wi‑Fi unmanaged by default on ISO; we'll re-enable it dynamically at login
              environment.etc."NetworkManager/conf.d/10-easyos-unmanaged-wifi.conf" = {
                text = ''
                  [keyfile]
                  unmanaged-devices=type:wifi
                '';
                mode = "0644";
              };

              # Ensure the live ISO logs in automatically so the installer can run
              # The minimal installer image creates a 'nixos' user; we force autologin to it
              services.getty.autologinUser = lib.mkForce "nixos";

              # Make sure the nixos user can sudo without a password (typical for installer ISOs)
              security.sudo.wheelNeedsPassword = lib.mkForce false;

              # Ensure nixos user exists and is in wheel group with passwordless sudo
              users.users.nixos = {
                isNormalUser = true;
                extraGroups = [ "wheel" "networkmanager" ];
                # Make password handling unambiguous: only initialPassword set
                initialPassword = "";              # autologin user; no password needed
                initialHashedPassword = lib.mkForce null;
                hashedPassword = lib.mkForce null;
                hashedPasswordFile = lib.mkForce null;
                password = lib.mkForce null;
              };

              # Extra safety: allow wheel group passwordless sudo via sudoers rule
              security.sudo.extraRules = [
                {
                  users = [ "nixos" ];
                  commands = [
                    {
                      command = "ALL";
                      options = [ "NOPASSWD" ];
                    }
                  ];
                }
              ];

              # Create installer script in /etc
              environment.etc."easyos-install.sh" = {
                text = ''
                  #!/usr/bin/env bash
                  set -euo pipefail
                  # Log everything to a session log for troubleshooting
                  LOGFILE=/tmp/easyos-install.log
                  exec > >(tee -a "$LOGFILE") 2>&1

                  # Use a dedicated TTY file descriptor (fd 3) for prompts so
                  # logging/tee on stdout/stderr never interferes with input.
                  TTY_DEV=/dev/tty
                  if [ -c "$TTY_DEV" ]; then
                    # Open a dedicated fd (3) to the controlling TTY for prompts
                    exec 3<>"$TTY_DEV" || true
                  else
                    # Fallbacks if /dev/tty unavailable (very rare on live ISO)
                    exec 3>&1 || true
                  fi
                  cleanup_fds() { exec 3>&- 3<&- 2>/dev/null || true; }
                  trap cleanup_fds EXIT

                  prompt() {
                    # usage: prompt "Question [default]: " varname [default]
                    local _msg="$1"; shift
                    local _var="$1"; shift
                    local _def="${1:-}"
                    local _ans=""
                    # Show prompt on both the TTY and stdout for visibility
                    printf "%s" "${_msg}" >&3 2>/dev/null || true
                    printf "%s" "${_msg}" 1>&1 2>/dev/null || true
                    if [ -t 3 ]; then
                      IFS= read -r _ans <&3 || _ans=""
                    elif [ -r /dev/tty ]; then
                      IFS= read -r _ans </dev/tty || _ans=""
                    else
                      IFS= read -r _ans || _ans=""
                    fi
                    if [ -z "${_ans}" ] && [ -n "${_def}" ]; then
                      eval "${_var}='${_def}'"
                    else
                      eval "${_var}='${_ans}'"
                    fi
                  }
                  prompt_secret() {
                    # usage: prompt_secret "Password: " varname
                    local _msg="$1"; shift
                    local _var="$1"; shift
                    local _ans=""
                    # Mirror prompt on stdout so users always see it even if fd 3 is not visible
                    printf "%s" "${_msg}" >&3 2>/dev/null || true
                    printf "%s" "${_msg}" 1>&1 2>/dev/null || true
                    if [ -t 3 ]; then
                      stty -echo <&3 2>/dev/null || true
                      IFS= read -r _ans <&3 || _ans=""
                      stty echo <&3 2>/dev/null || true
                      printf "\n" >&3 2>/dev/null || true
                    elif [ -r /dev/tty ]; then
                      stty -echo </dev/tty 2>/dev/null || true
                      IFS= read -r _ans </dev/tty || _ans=""
                      stty echo </dev/tty 2>/dev/null || true
                      printf "\n" 1>&1 2>/dev/null || true
                    else
                      # Last resort: read from stdin (may be piped)
                      stty -echo 2>/dev/null || true
                      IFS= read -r _ans || _ans=""
                      stty echo 2>/dev/null || true
                      printf "\n" 1>&1 2>/dev/null || true
                    fi
                    eval "${_var}='${_ans}'"
                  }

                  # Reduce kernel messages on the console to avoid noisy interleaving
                  # that can obscure or interrupt prompts.
                  (dmesg -n 1 2>/dev/null || true)
                  if [ -w /proc/sys/kernel/printk ]; then echo "3 3 3 3" > /proc/sys/kernel/printk 2>/dev/null || true; fi

                  # Check if running as root
                  if [ "$EUID" -ne 0 ]; then
                    echo "ERROR: This installer must be run as root."
                    echo "Please run: sudo easyos-install"
                    exit 1
                  fi

                  # Minimal self-check: verify heredoc markers exist in this script
                  validate_heredocs() {
                    local self="/etc/easyos-install.sh"
                    local openEON closeEON openEOCRED closeEOCRED
                    # Use patterns that won't match themselves in the grep search
                    openEON=$(grep -Ec "<<'?E""ON'?" "$self" 2>/dev/null || echo 0)
                    closeEON=$(grep -Ec "^E""ON\$" "$self" 2>/dev/null || echo 0)
                    openEOCRED=$(grep -Ec "<<E""OCRED" "$self" 2>/dev/null || echo 0)
                    closeEOCRED=$(grep -Ec "^E""OCRED\$" "$self" 2>/dev/null || echo 0)
                    if [ "$openEON" -ne "$closeEON" ] || [ "$openEOCRED" -ne "$closeEOCRED" ]; then
                      echo "ERROR: Installer script appears malformed (heredoc markers mismatch)."
                      echo "Please rebuild the ISO and try again."
                      exit 1
                    fi
                  }
                  validate_heredocs

                  # Check network connectivity - already done by ISO boot, just verify
                  echo "Checking network connectivity..."
                  if ! curl -s --max-time 5 https://github.com > /dev/null 2>&1; then
                    echo ""
                    echo "⚠ No internet connection detected."
                    echo ""
                    echo "Opening network configuration..."
                    sleep 1

                    nmtui

                    # Check again
                    echo ""
                    echo "Re-checking connectivity..."
                    if curl -s --max-time 5 https://github.com > /dev/null 2>&1; then
                      echo "✓ Internet connection established!"
                    else
                      echo ""
                      echo "⚠ Still no internet connection."
                      echo "Installation requires internet access to download packages."
                      echo "You can run 'sudo nmtui' to configure network, or continue anyway."
                      echo ""
                      prompt "Continue with installation? (y/N): " CONTINUE
                      if [[ ! "$CONTINUE" =~ ^[Yy]$ ]]; then
                        echo "Installation cancelled."
                        exit 0
                      fi
                    fi
                  else
                    echo "✓ Internet connection detected."
                  fi

                  clear
                  echo "╔════════════════════════════════════════════════════════════════╗"
                  echo "║                      EASYOS Installer                          ║"
                  echo "╚════════════════════════════════════════════════════════════════╝"
                  echo ""
                  echo "This installer will:"
                  echo "  • Partition and format the target drive (ALL DATA WILL BE LOST)"
                  echo "  • Install NixOS with the easyos configuration"
                  echo "  • Set up Btrfs with compression and subvolumes"
                  echo "  • Clone the easyos flake from GitHub"
                  echo ""

                  # List available block devices
                  echo "Available drives:"
                  echo "────────────────────────────────────────────────────────────────"
                  lsblk -d -o NAME,SIZE,MODEL | grep -v "loop"
                  echo ""

                  # Get target device
                  while true; do
                    prompt "Target device (e.g., /dev/sda or /dev/nvme0n1): " DEVICE

                    if [ ! -b "$DEVICE" ]; then
                      echo "⚠ ERROR: $DEVICE is not a valid block device"
                      continue
                    fi

                    # Show what's on the device
                    echo ""
                    echo "Current partitions on $DEVICE:"
                    lsblk "$DEVICE" || true
                    echo ""

                    # Final confirmation with explicit warning
                    echo "⚠⚠⚠  WARNING  ⚠⚠⚠"
                    echo "This will COMPLETELY ERASE $DEVICE and ALL its data!"
                    echo "This action CANNOT be undone."
                    echo ""
                    prompt "Type 'YES' in all caps to confirm: " CONFIRM

                    if [ "$CONFIRM" = "YES" ]; then
                      break
                    else
                      echo "Installation cancelled."
                      exit 1
                    fi
                  done

                  # Get hostname
                  prompt "Hostname for this system [easyos]: " HOSTNAME
                  HOSTNAME=''${HOSTNAME:-easyos}

                  # Get admin username
                  prompt "Admin username [easyadmin]: " ADMIN
                  ADMIN=''${ADMIN:-easyadmin}

                  # Get admin password (with confirmation)
                  while true; do
                    prompt_secret "Admin password: " ADMIN_PASS
                    prompt_secret "Confirm admin password: " ADMIN_PASS2
                    if [ "''${ADMIN_PASS}" != "''${ADMIN_PASS2}" ]; then
                      echo "Passwords do not match. Please try again."
                    elif [ -z "''${ADMIN_PASS}" ]; then
                      echo "Password cannot be empty. Please try again."
                    else
                      break
                    fi
                  done

                  # Root password choice
                  prompt "Use the same password for root? [Y/n]: " SAME_ROOT
                  SAME_ROOT=''${SAME_ROOT:-Y}
                  if [[ "$SAME_ROOT" =~ ^[Nn]$ ]]; then
                    while true; do
                      prompt_secret "Root password: " ROOT_PASS
                      prompt_secret "Confirm root password: " ROOT_PASS2
                      if [ "''${ROOT_PASS}" != "''${ROOT_PASS2}" ]; then
                        echo "Passwords do not match. Please try again."
                      elif [ -z "''${ROOT_PASS}" ]; then
                        echo "Password cannot be empty. Please try again."
                      else
                        break
                      fi
                    done
                  else
                    ROOT_PASS="''${ADMIN_PASS}"
                  fi

                  # Hash passwords using SHA-512
                  ADMIN_HASH=$(openssl passwd -6 "''${ADMIN_PASS}")
                  ROOT_HASH=$(openssl passwd -6 "''${ROOT_PASS}")
                  # Safety net to avoid post-install lockout
                  if [ -z ""${ADMIN_HASH}"" ] || [ -z ""${ROOT_HASH}"" ]; then
                    echo "WARNING: Password hashing failed; defaulting admin/root password to 'easyos'."
                    ADMIN_HASH=$(openssl passwd -6 "easyos")
                    ROOT_HASH="$ADMIN_HASH"
                  fi

                  echo ""
                  echo "══════════════════════════════════════════════════════════════"
                  echo "Installation Summary:"
                  echo "  Target: $DEVICE"
                  echo "  Hostname: $HOSTNAME"
                  echo "  Admin user: $ADMIN"
                  echo "══════════════════════════════════════════════════════════════"
                  echo ""
                  prompt "Press ENTER to begin installation or Ctrl+C to cancel..." _

                  # TPM2 detection and encryption option
                  ENCRYPT=0
                  HAS_TPM=0
                  TPM_DEV=""
                  if [ -c /dev/tpmrm0 ]; then TPM_DEV="/dev/tpmrm0"; HAS_TPM=1; fi
                  if [ "$HAS_TPM" -eq 0 ] && [ -c /dev/tpm0 ]; then TPM_DEV="/dev/tpm0"; HAS_TPM=1; fi
                  if [ "$HAS_TPM" -eq 1 ] && command -v systemd-cryptenroll >/dev/null 2>&1; then
                    echo ""
                    echo "TPM2 device detected ($TPM_DEV)."
                    echo "You can enable disk encryption for the Btrfs data partition and enroll TPM2 for auto-unlock."
                    echo "A printed recovery key will be generated as fallback."
                    prompt "Enable disk encryption with TPM2 auto-unlock? [y/N]: " ENC_CHOICE
                    if [[ "$ENC_CHOICE" =~ ^[Yy]$ ]]; then ENCRYPT=1; fi
                  else
                    echo ""
                    echo "No compatible TPM2 device found or systemd-cryptenroll unavailable."
                    echo "Proceeding without disk encryption."
                  fi

                  echo ""
                  echo "⚙ Preparing $DEVICE..."
                  # Unmount any existing partitions on the target device
                  umount -R "$DEVICE"* 2>/dev/null || true
                  # Close any LUKS mappings that might be using this device
                  for mapper in /dev/mapper/*; do
                    if [ -L "$mapper" ] && cryptsetup status "$(basename "$mapper")" 2>/dev/null | grep -q "$DEVICE"; then
                      cryptsetup close "$(basename "$mapper")" 2>/dev/null || true
                    fi
                  done
                  # Wipe any existing partition table and filesystem signatures
                  wipefs -af "$DEVICE" 2>/dev/null || true
                  dd if=/dev/zero of="$DEVICE" bs=1M count=10 conv=fsync 2>/dev/null || true

                  echo "⚙ Partitioning $DEVICE..."
                  if [ -d /sys/firmware/efi ]; then
                    echo "  Firmware: UEFI (systemd-boot)"
                    parted -s "$DEVICE" -- mklabel gpt
                    parted -s "$DEVICE" -- mkpart ESP fat32 1MiB 512MiB
                    parted -s "$DEVICE" -- set 1 esp on
                    parted -s "$DEVICE" -- mkpart primary btrfs 512MiB 100%

                    # Handle both /dev/sdX and /dev/nvmeXnY naming
                    if [[ "$DEVICE" =~ "nvme" ]]; then
                      BOOT="''${DEVICE}p1"
                      ROOT="''${DEVICE}p2"
                    else
                      BOOT="''${DEVICE}1"
                      ROOT="''${DEVICE}2"
                    fi
                    BOOT_MODE="uefi"
                  else
                    echo "  Firmware: BIOS/Legacy (GRUB)"
                    parted -s "$DEVICE" -- mklabel gpt
                    parted -s "$DEVICE" -- mkpart biosboot 1MiB 2MiB
                    parted -s "$DEVICE" -- set 1 bios_grub on
                    if [ "$ENCRYPT" -eq 1 ]; then
                      # When encrypting root on BIOS, create an unencrypted /boot partition
                      parted -s "$DEVICE" -- mkpart boot ext4 2MiB 1026MiB
                      parted -s "$DEVICE" -- mkpart primary btrfs 1026MiB 100%
                      if [[ "$DEVICE" =~ "nvme" ]]; then
                        BOOT="''${DEVICE}p2"
                        ROOT="''${DEVICE}p3"
                      else
                        BOOT="''${DEVICE}2"
                        ROOT="''${DEVICE}3"
                      fi
                    else
                      parted -s "$DEVICE" -- mkpart primary btrfs 2MiB 100%
                      if [[ "$DEVICE" =~ "nvme" ]]; then
                        ROOT="''${DEVICE}p2"
                      else
                        ROOT="''${DEVICE}2"
                      fi
                      BOOT="" # no separate /boot
                    fi
                    BOOT_MODE="bios"
                  fi

                  # Force kernel to re-read partition table
                  partprobe "$DEVICE" 2>/dev/null || true
                  udevadm settle --timeout=5 2>/dev/null || true
                  sleep 3  # Give kernel time to recognize new partitions

                  # Wipe any existing filesystem signatures on the NEW partitions
                  wipefs -af "$ROOT" 2>/dev/null || true
                  if [ -n "''${BOOT:-}" ]; then
                    wipefs -af "$BOOT" 2>/dev/null || true
                  fi

                  echo "⚙ Formatting partitions..."
                  if [ "$BOOT_MODE" = "uefi" ]; then
                    mkfs.fat -F 32 -n BOOT "$BOOT"
                  elif [ "$ENCRYPT" -eq 1 ] && [ -n "''${BOOT:-}" ]; then
                    mkfs.ext4 -F -L boot "$BOOT"
                  fi

                  CRYPT_DEV=""
                  if [ "$ENCRYPT" -eq 1 ]; then
                    echo "  • Setting up LUKS2 on $ROOT with TPM2 auto-unlock (to be enrolled)"
                    # Create a temporary passphrase for initial format and enrollment
                    TEMP_PASS=$(openssl rand -base64 32)
                    # Format LUKS2 container
                    echo -n "$TEMP_PASS" | cryptsetup luksFormat --type luks2 --pbkdf argon2id "$ROOT" -
                    # Open it as cryptroot
                    echo -n "$TEMP_PASS" | cryptsetup open "$ROOT" cryptroot --key-file -
                    CRYPT_DEV="/dev/mapper/cryptroot"
                    # Create Btrfs on the encrypted device
                    mkfs.btrfs -f -L nixos "$CRYPT_DEV"
                  else
                    mkfs.btrfs -f -L nixos "$ROOT"
                  fi

                  echo "⚙ Creating btrfs subvolumes..."
                  if [ "$ENCRYPT" -eq 1 ]; then
                    mount "$CRYPT_DEV" /mnt
                  else
                    mount "$ROOT" /mnt
                  fi
                  btrfs subvolume create /mnt/root
                  btrfs subvolume create /mnt/home
                  btrfs subvolume create /mnt/nix
                  btrfs subvolume create /mnt/var
                  umount /mnt

                  echo "⚙ Mounting filesystems..."
                  if [ "$ENCRYPT" -eq 1 ]; then
                    mount -o subvol=root,compress=zstd "$CRYPT_DEV" /mnt
                  else
                    mount -o subvol=root,compress=zstd "$ROOT" /mnt
                  fi
                  mkdir -p /mnt/{home,nix,var}
                  [ "$BOOT_MODE" = "uefi" ] && mkdir -p /mnt/boot || true
                  if [ "$ENCRYPT" -eq 1 ]; then
                    mount -o subvol=home,compress=zstd "$CRYPT_DEV" /mnt/home
                    mount -o subvol=nix,compress=zstd,noatime "$CRYPT_DEV" /mnt/nix
                    mount -o subvol=var,compress=zstd "$CRYPT_DEV" /mnt/var
                  else
                    mount -o subvol=home,compress=zstd "$ROOT" /mnt/home
                    mount -o subvol=nix,compress=zstd,noatime "$ROOT" /mnt/nix
                    mount -o subvol=var,compress=zstd "$ROOT" /mnt/var
                  fi
                  if [ "$BOOT_MODE" = "uefi" ] || { [ "$BOOT_MODE" = "bios" ] && [ -n "''${BOOT:-}" ]; }; then
                    mount "$BOOT" /mnt/boot
                  fi

                  echo "⚙ Creating 8GiB swapfile (with no CoW)..."
                  # Create swapfile on btrfs correctly: set NOCOW before writing
                  touch /mnt/swapfile
                  chattr +C /mnt/swapfile 2>/dev/null || true
                  fallocate -l 8G /mnt/swapfile 2>/dev/null || dd if=/dev/zero of=/mnt/swapfile bs=1M count=8192
                  chmod 600 /mnt/swapfile
                  mkswap /mnt/swapfile
                  # Do not enable swap during installation to avoid holding the
                  # encrypted device open when we enroll TPM. The swapfile will
                  # be activated on first boot by NixOS.
                  # swapon /mnt/swapfile || true

                  echo "⚙ Generating hardware configuration..."
                  nixos-generate-config --root /mnt

                  # If encryption was selected, enroll TPM2 and a recovery key now
                  if [ "$ENCRYPT" -eq 1 ]; then
                    echo "⚙ Enrolling TPM2 auto-unlock and generating recovery key..."
                    echo "  Closing encrypted device for enrollment (required by systemd-cryptenroll)..."
                    # systemd-cryptenroll requires the LUKS device to be closed for enrollment
                    # Ensure nothing is using /mnt
                    sync
                    # Unmount in reverse order (deepest first)
                    umount /mnt/var 2>/dev/null || true
                    umount /mnt/nix 2>/dev/null || true
                    umount /mnt/home 2>/dev/null || true
                    umount /mnt/boot 2>/dev/null || true
                    umount /mnt 2>/dev/null || true
                    udevadm settle --timeout=5 2>/dev/null || true
                    sleep 1
                    # Close the encrypted device with retry logic
                    CLOSED=0
                    for i in $(seq 1 10); do
                      if cryptsetup close cryptroot 2>/dev/null; then
                        CLOSED=1
                        break
                      fi
                      # If close failed, check what's holding it
                      if [ $i -eq 1 ]; then
                        echo "  Device busy, identifying processes..."
                        lsof 2>/dev/null | grep -i crypt || true
                        fuser -v /dev/mapper/cryptroot 2>&1 || true
                      fi
                      echo "  Waiting for cryptroot to be free... ($i/10)"
                      fuser -km /dev/mapper/cryptroot 2>/dev/null || true
                      sleep 1
                    done
                    if [ $CLOSED -eq 0 ]; then
                      echo "ERROR: Could not close cryptroot after 10 attempts. Device is held open."
                      exit 1
                    fi

                    # Check for TPM2 support
                    echo "  Checking TPM2 hardware..."
                    if [ ! -e /dev/tpmrm0 ] && [ ! -e /dev/tpm0 ]; then
                      echo "WARNING: No TPM device found. TPM unlock will not work."
                      echo "  Continuing with recovery key only..."
                      TPM_AVAILABLE=0
                    else
                      TPM_AVAILABLE=1
                      echo "  TPM device detected: $(ls /dev/tpm* | head -1)"
                    fi

                    # Enroll TPM2 with device closed (proper production setup)
                    if [ $TPM_AVAILABLE -eq 1 ]; then
                      echo "  Enrolling TPM2 unlock (PCR 7 - Secure Boot state)..."
                      # PCR 7 = Secure Boot state (most important for auto-unlock)
                      # PCR 11 = Unified kernel image (if using systemd-boot UKI)
                      ENROLL_TPM_OUT=$(systemd-cryptenroll "$ROOT" \
                        --unlock-key-file=<(printf "%s" "$TEMP_PASS") \
                        --tpm2-device=auto \
                        --tpm2-pcrs=7 \
                        --wipe-slot=tpm2 2>&1) || {
                          echo "WARNING: systemd-cryptenroll TPM2 enrollment failed"
                          echo "$ENROLL_TPM_OUT"
                          echo "  Continuing without TPM unlock (recovery key will be required at boot)..."
                          TPM_AVAILABLE=0
                        }

                      if [ $TPM_AVAILABLE -eq 1 ]; then
                        echo "  ✓ TPM2 enrollment successful"
                        echo "    Bound to PCR 7 (Secure Boot state)"
                        echo "    Your system will auto-unlock if:"
                        echo "    - TPM is present"
                        echo "    - Secure Boot state unchanged"
                        echo "    - UEFI firmware unchanged"
                      fi
                    fi

                    # Add a recovery key as a separate operation (prints key to stdout)
                    echo "  Adding recovery key..."
                    RECOVERY_OUT=$(systemd-cryptenroll "$ROOT" \
                      --unlock-key-file=<(printf "%s" "$TEMP_PASS") \
                      --recovery-key 2>&1) || {
                        echo "ERROR: systemd-cryptenroll recovery-key enrollment failed"
                        echo "$RECOVERY_OUT"
                        exit 1
                      }

                    # Extract recovery key robustly from systemd-cryptenroll output.
                    # Newer systemd prints:
                    #   "A secret recovery key has been generated for this volume:"
                    #   <KEY-LINE>
                    # Capture the line immediately following that sentence.
                    RECOVERY_KEY=$(printf "%s\n" "$RECOVERY_OUT" \
                      | awk '/secret recovery key/ {getline; print $0}' \
                      | tr -d '\r' \
                      | xargs || true)
                    if [ -z "$RECOVERY_KEY" ]; then
                      echo "$RECOVERY_OUT"
                      echo "ERROR: Could not parse recovery key from systemd-cryptenroll output."
                      exit 1
                    fi

                    # Remove the temporary passphrase slot (no longer needed)
                    echo "  Removing temporary passphrase..."
                    echo -n "$TEMP_PASS" | cryptsetup luksRemoveKey "$ROOT" - || true

                    # Reopen device for installation using the recovery key
                    echo "  Reopening encrypted device with recovery key..."
                    echo -n "$RECOVERY_KEY" | cryptsetup open "$ROOT" cryptroot --key-file -
                    CRYPT_DEV="/dev/mapper/cryptroot"

                    # Remount all subvolumes for installation
                    mount -o subvol=root,compress=zstd "$CRYPT_DEV" /mnt
                    mkdir -p /mnt/{home,nix,var,boot}
                    mount -o subvol=home,compress=zstd "$CRYPT_DEV" /mnt/home
                    mount -o subvol=nix,compress=zstd,noatime "$CRYPT_DEV" /mnt/nix
                    mount -o subvol=var,compress=zstd "$CRYPT_DEV" /mnt/var
                    if [ "$BOOT_MODE" = "uefi" ] || [ -n "''${BOOT:-}" ]; then
                      mount "$BOOT" /mnt/boot
                    fi
                    # Ensure mounts for nixos-install are in place (root already mounted above)
                    mount "$BOOT" /mnt/boot
                    mount -o subvol=home "$CRYPT_DEV" /mnt/home
                    mount -o subvol=nix "$CRYPT_DEV" /mnt/nix
                    mount -o subvol=var "$CRYPT_DEV" /mnt/var
                    # Persist recovery key securely on target (user should move it to a safe place)
                    mkdir -p /mnt/etc/easy
                    printf "%s\n" "$RECOVERY_KEY" > /mnt/etc/easy/recovery.key
                    chmod 600 /mnt/etc/easy/recovery.key
                    echo "  Recovery key saved to /etc/easy/recovery.key on the installed system."
                    echo ""
                    echo "══════════════════════════════════════════════════════════════"
                    echo "RECOVERY KEY - Scan this QR code or write it down:"
                    echo ""
                    echo "  $RECOVERY_KEY"
                    echo ""
                    # Display QR code for easy scanning with phone
                    if command -v qrencode >/dev/null 2>&1; then
                      qrencode -t ANSIUTF8 -m 2 "$RECOVERY_KEY"
                    fi
                    echo ""
                    echo "══════════════════════════════════════════════════════════════"
                    echo ""
                    prompt "Press ENTER after saving the recovery key to continue..." _
                    echo ""
                    # Prepare easy-encryption.nix for TPM auto-unlock
                    LUKS_UUID=$(cryptsetup luksUUID "$ROOT")
                    if [ $TPM_AVAILABLE -eq 1 ]; then
                      cat > /mnt/etc/nixos/easyos/easy-encryption.nix <<EON
{ config, lib, pkgs, ... }:
{
  # Enable TPM2 stack for automatic unlocking
  security.tpm2 = {
    enable = lib.mkForce true;
    # Ensure TPM kernel modules load early
    pkgs = [ pkgs.tpm2-tss ];
  };

  # Use systemd in initrd for TPM2 unlock support
  boot.initrd.systemd.enable = lib.mkForce true;

  # Configure LUKS device with TPM2 auto-unlock
  boot.initrd.luks.devices.cryptroot = {
    device = lib.mkForce "/dev/disk/by-uuid/$LUKS_UUID";
    preLVM = lib.mkForce true;
    # Allow TPM unlock with fallback to recovery key
    crypttabExtraOpts = [ "tpm2-device=auto" "headless=1" "timeout=0" ];
  };

  # Ensure cryptsetup and systemd-cryptenroll are available
  environment.systemPackages = with pkgs; [
    cryptsetup
    tpm2-tools
  ];
}
EON
                    else
                      # No TPM - encryption only uses recovery key
                      cat > /mnt/etc/nixos/easyos/easy-encryption.nix <<EON
{ config, lib, pkgs, ... }:
{
  # Use systemd in initrd for better unlock UX
  boot.initrd.systemd.enable = lib.mkForce true;

  # Configure LUKS device (manual unlock required)
  boot.initrd.luks.devices.cryptroot = {
    device = lib.mkForce "/dev/disk/by-uuid/$LUKS_UUID";
    preLVM = lib.mkForce true;
  };

  environment.systemPackages = with pkgs; [ cryptsetup ];
}
EON
                    fi
                  fi

                  # Detect which channel this ISO was built with
                  CHANNEL="stable"
                  if [ -f /etc/easy/channel ]; then
                    CHANNEL=$(cat /etc/easy/channel)
                  fi

                  echo "⚙ Setting up easyos flake in /mnt/etc/nixos..."
                  mkdir -p /mnt/etc/nixos

                  # Extract the flake from the tarball shipped in the ISO
                  # This avoids read-only filesystem issues and accidental downgrades
                  if [ -f /etc/nixos/easyos.tar.gz ]; then
                    echo "Extracting flake from ISO..."
                    tar xzf /etc/nixos/easyos.tar.gz -C /mnt/etc/nixos/
                  elif [ -d /etc/nixos/easyos ]; then
                    # Fallback for older ISOs that shipped the directory directly
                    echo "Copying flake from ISO (legacy method)..."
                    cp -r /etc/nixos/easyos /mnt/etc/nixos/
                    chmod -R u+w /mnt/etc/nixos/easyos
                  else
                    echo "WARNING: Flake source missing from ISO; falling back to GitHub clone."
                    GIT_TERMINAL_PROMPT=0 git clone https://github.com/doughty247/easyos.git /mnt/etc/nixos/easyos
                  fi

                  echo "⚙ Importing hardware-configuration.nix into easyos..."
                  # Copy hardware config to easyos directory
                  cp /mnt/etc/nixos/hardware-configuration.nix /mnt/etc/nixos/easyos/
                  echo "--- hardware-configuration.nix (installed) ---"
                  cat /mnt/etc/nixos/easyos/hardware-configuration.nix
                  echo "---------------------------------------------"

                  if [ "$BOOT_MODE" = "uefi" ]; then
                    echo "⚙ Configuring bootloader (systemd-boot)..."
                    cat > /mnt/etc/nixos/easyos/easy-bootloader.nix <<'EON'
{ lib, ... }: {
  boot.loader.systemd-boot.enable = lib.mkForce true;
  boot.loader.efi.canTouchEfiVariables = lib.mkForce true;
  boot.loader.grub.enable = lib.mkForce false;
  boot.loader.grub.devices = lib.mkForce [ ];
}
EON
                    # Validate expected flags in rendered file
                    if ! grep -q "systemd-boot.enable = lib.mkForce true;" /mnt/etc/nixos/easyos/easy-bootloader.nix; then
                      echo "ERROR: systemd-boot configuration not rendered as expected."; exit 1; fi
                    if grep -q "grub.enable = lib.mkForce true;" /mnt/etc/nixos/easyos/easy-bootloader.nix; then
                      echo "ERROR: GRUB should be disabled in UEFI mode."; exit 1; fi
                  else
                    echo "⚙ Configuring bootloader (GRUB BIOS)..."
                    # Write bootloader config with direct device injection (avoiding both Nix and bash string interpolation issues)
                    {
                      echo '{ lib, ... }: {'
                      echo '  boot.loader.systemd-boot.enable = lib.mkForce false;'
                      echo '  boot.loader.efi.canTouchEfiVariables = lib.mkForce false;'
                      echo '  boot.loader.grub.enable = lib.mkForce true;'
                      echo "  boot.loader.grub.devices = lib.mkForce [ \"$DEVICE\" ];"
                      echo '}'
                    } > /mnt/etc/nixos/easyos/easy-bootloader.nix
                    # Validate GRUB device injection
                    if ! grep -q "grub.enable = lib.mkForce true;" /mnt/etc/nixos/easyos/easy-bootloader.nix; then
                      echo "ERROR: GRUB configuration not rendered as expected."; exit 1; fi
                    if ! grep -q "$(printf "%s" "$DEVICE" | sed 's/[\\.^$*\[\]{}()|+?]/\\&/g')" /mnt/etc/nixos/easyos/easy-bootloader.nix; then
                      echo "ERROR: Selected device $DEVICE was not injected into GRUB devices."; exit 1; fi
                    echo "--- Generated bootloader config ---"
                    cat /mnt/etc/nixos/easyos/easy-bootloader.nix
                    echo "-----------------------------------"
                  fi

                  echo "⚙ Creating /mnt/etc/easy/config.json..."
                  mkdir -p /mnt/etc/easy
                  cp /mnt/etc/nixos/easyos/etc/easy/config.example.json /mnt/etc/easy/config.json
                  # Mark system as installed for post-install services
                  echo "installed" > /mnt/etc/easy/installed
                  # Update hostname and admin username in config.json
                  if command -v jq >/dev/null 2>&1; then
                    TMP_JSON=$(mktemp)
                    jq --arg host "$HOSTNAME" --arg admin "$ADMIN" '.hostName=$host | .users.admin.name=$admin' /mnt/etc/easy/config.json > "$TMP_JSON" && mv "$TMP_JSON" /mnt/etc/easy/config.json
                  else
                    # Fallback to sed if jq isn't available (should not happen)
                    sed -i "s/\"easyos\"/\"$HOSTNAME\"/" /mnt/etc/easy/config.json
                    sed -i "s/\"easyadmin\"/\"$ADMIN\"/" /mnt/etc/easy/config.json
                  fi

                  # Persist chosen credentials as a small module to override defaults
                  # Also satisfy NixOS user assertions by declaring a primary group and isNormalUser
                  cat > /mnt/etc/nixos/easyos/easy-credentials.nix <<EOCRED
{ lib, ... }:
{
  # Ensure a primary group exists for the admin user
  users.groups.''${ADMIN} = {};

  users.users.''${ADMIN} = {
    isNormalUser = lib.mkForce true;
    group = lib.mkForce "''${ADMIN}";
    hashedPassword = lib.mkForce "''${ADMIN_HASH}";
  };

  users.users.root.hashedPassword = lib.mkForce "''${ROOT_HASH}";
}
EOCRED

                  # Store channel information
                  echo "$CHANNEL" > /mnt/etc/easy/channel

                  # Remove VCS metadata to avoid 'dirty tree' warnings during install
                  rm -rf /mnt/etc/nixos/easyos/.git 2>/dev/null || true

                  # Determine flake attribute for selected channel (nixos-install expects just the name)
                  FLAKE_ATTR="easyos-$CHANNEL"

                  echo ""
                  echo "⚙ Installing NixOS with $CHANNEL channel (this will take several minutes)..."
                  echo "   Using ISO cache to speed up installation..."

                  nixos-install --flake "/mnt/etc/nixos/easyos#$FLAKE_ATTR" --impure --no-root-passwd --option pure-eval false

                  echo ""
                  echo "⚙ System installation complete!"
                  echo ""
                  echo "╔════════════════════════════════════════════════════════════════╗"
                  echo "║            ✓ Installation Complete!                           ║"
                  echo "╚════════════════════════════════════════════════════════════════╝"
                  echo ""
                  echo "Installed channel: $CHANNEL"
                  echo ""
                  if [ "''${ENCRYPT:-0}" -eq 1 ]; then
                    echo "Disk encryption: ENABLED (TPM2 auto-unlock)"
                    echo "Recovery key (write this down and store safely):"
                    if [ -n "''${RECOVERY_KEY:-}" ]; then
                      echo "  $RECOVERY_KEY"
                      echo ""
                      # Display QR code again for convenience
                      if command -v qrencode >/dev/null 2>&1; then
                        qrencode -t ANSIUTF8 -m 2 "$RECOVERY_KEY"
                      fi
                    else
                      echo "  (Saved at /etc/easy/recovery.key on the installed system)"
                    fi
                    echo ""
                  fi
                  echo "What happens on first boot:"
                  echo "  • Auto-login as '$ADMIN'"
                  echo "  • WiFi hotspot will start (if WiFi adapter present)"
                  echo "  • Web UI available at http://<ip>:8088/"
                  echo ""
                  echo "First-run setup options:"
                  echo "  1. Ethernet: Connect cable, find IP, access web UI"
                  echo "  2. WiFi Hotspot: Connect to 'EASY-Setup', go to http://10.42.0.1:8088/"
                  echo "  3. Console: Follow on-screen instructions after boot"
                  echo ""
                  echo "Use the web UI to set your admin password and configure the system."
                  echo ""
                  # Persist log to target for postmortem
                  if [ -d /mnt/etc ]; then
                    cp -f "$LOGFILE" /mnt/etc/easyos-install.log || true
                  fi
                  prompt "Press ENTER to reboot now, or Ctrl+C to stay in the live environment..." _
                  reboot
                '';
                mode = "0755";
              };

              # Make installer accessible in root home
              system.activationScripts.easyosInstaller = ''
                ln -sf /etc/easyos-install.sh /root/install.sh
              '';
            }
          ];
        };
    in {
      # Developer convenience: formatter
      formatter = forAllSystems (system: nixpkgs.legacyPackages.${system}.nixpkgs-fmt);

      nixosConfigurations = {
        # Default stable channel
        easyos = mkEasyOS { };

        # Explicit channel configurations
        easyos-stable = mkEasyOS { channel = "stable"; };
        easyos-beta = mkEasyOS { channel = "beta"; };
        easyos-preview = mkEasyOS { channel = "preview"; };

        # Bootable ISO installers (one per channel)
        iso = mkISO { }; # stable by default
        iso-stable = mkISO { channel = "stable"; };
        iso-beta = mkISO { channel = "beta"; };
        iso-preview = mkISO { channel = "preview"; };
      };
    };
}
